---
title: Data table
description: The data table component allows for the flexible display and sorting of information.
tabs: ["Usage", "Style", "Code", "Accessibility"]
---

<PageDescription>

A set of primitives to help teams build simple, flexible, and WAI-ARIA
compliant tables in React

</PageDescription>

<AnchorLinks>

<AnchorLink>Use-cases</AnchorLink>
<AnchorLink>Component API</AnchorLink>
<AnchorLink>Reference</AnchorLink>

</AnchorLinks>

The `carbon-components-react` package exports a collection of components used to
build a table in React. In addition to these presentational components, we also offer a `DataTable` component that helps you add sorting, row
expansion, selection, filtering, and more to your table.

To build a default table without any interaction, you can use the following set of
table components. Each one matches one-to-one with the structure of a table in HTML.

```jsx
import {
  Table,
  TableHead,
  TableRow,
  TableHeader,
  TableBody,
  TableCell,
} from "carbon-components-react";

function MyComponent() {
  return (
    <Table>
      <TableHead>
        <TableRow>
          <TableHeader>Column A</TableHeader>
          <TableHeader>Column B</TableHeader>
          <TableHeader>Column C</TableHeader>
        </TableRow>
      </TableHead>
      <TableBody>
        <TableRow>
          <TableCell>Row 1, Column A</TableCell>
          <TableCell>Row 1, Column B</TableCell>
          <TableCell>Row 1, Column C</TableCell>
        </TableRow>
      </TableBody>
    </Table>
  );
}
```

If you want additional functionality for your table, like sorting or filtering,
then you can use our `DataTable` component. This component follows the [render
prop pattern](https://reactjs.org/docs/render-props.html) to provide helpers
that you then use to add your desired functionality to the table.

As an example, we will use the `getHeaderProps` function to create a
sortable table.

```jsx
import {
  DataTable,
  Table,
  TableHead,
  TableRow,
  TableHeader,
  TableBody,
  TableCell,
} from "carbon-components-react";

const rows = [
  {
    id: "a",
    field: "Field a",
  },
  {
    id: "b",
    field: "Field b",
  },
  {
    id: "c",
    field: "Field c",
  },
];
const headers = [{ key: "field", header: "Field" }];

function MyComponent() {
  return (
    <DataTable rows={rows} headers={headers}>
      {({ rows, headers, getHeaderProps }) => (
        <Table>
          <TableHead>
            <TableRow>
              {headers.map((header) => (
                <TableHeader {...getHeaderProps({ header })}>
                  {header.header}
                </TableHeader>
              ))}
            </TableRow>
          </TableHead>
          <TableBody>
            {rows.map((row) => (
              <TableRow key={row.id}>
                {row.cells.map((cell) => (
                  <TableCell key={cell.id}>{cell.value}</TableCell>
                ))}
              </TableRow>
            ))}
          </TableBody>
        </Table>
      )}
    </DataTable>
  );
}
```

The `getHeaderProps` function is an example of a [prop getter](https://blog.kentcdodds.com/how-to-give-rendering-control-to-users-with-prop-getters-549eaef76acf) which provides the `TableHeader` component with the appropriate props for sorting.

There are other functions available which you can use to add additional behavior to your tables. For a full list of what is available, check out the [DataTable
render](#datatable-render) section below.

## Use-cases

The `DataTable` component offers support for sorting, expansion, selection, and
more. However, you can also build functionality on top of the `DataTable`
component if you need to add new behavior, or want to modify the default behavior of one of the helpers we provide.

### Sorting

In order to enable the sort behavior for a given `DataTable`, you will need to apply the `getHeaderProps` prop getter to each `TableHeader` that
you want to be sortable.

```jsx
import {
  DataTable,
  TableContainer,
  Table,
  TableHead,
  TableRow,
  TableHeader,
  TableBody,
  TableCell,
} from "carbon-components-react";

<DataTable rows={initialRows} headers={headers}>
  {({ rows, headers, getHeaderProps }) => (
    <TableContainer title="DataTable with sorting">
      <Table>
        <TableHead>
          <TableRow>
            {headers.map((header) => (
              <TableHeader {...getHeaderProps({ header })}>
                {header.header}
              </TableHeader>
            ))}
          </TableRow>
        </TableHead>
        <TableBody>
          {rows.map((row) => (
            <TableRow key={row.id}>
              {row.cells.map((cell) => (
                <TableCell key={cell.id}>{cell.value}</TableCell>
              ))}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  )}
</DataTable>;
```

#### Programmatic sorting

In addition to the prop getter specified in the previous section, you can also
change the sort status of the table by using the `sortBy` action made available
in your `render` prop function. This `sortBy` utility takes in the `key` of the
header you want to sort by as an argument. After invoking this method with the
given `key`, the table should be sorted by the header that you've specified.

#### Custom sorting

If the default sorting logic doesn't match your use-case, you can provide a
custom sort method as a `sortRow` prop to `DataTable`.

`sortRow` is a method that takes in the values of two cells, in addition to some
info, and should return -1, 0, or 1 as a result (mirroring the native sort
behavior in JavaScript).

The two cells that are passed in are derived by accessing the value of the sort
header in each row that we're comparing. For example, if we're sorting on the
`Foo` header, with the `foo` key available in each row, then for row `a` and row
`b` we would get the `a.foo` and `b.foo` field values.

As a result, a custom `sortRow` function would take on the following shape:

```js
const customSortRow = (cellA, cellB, { sortDirection, sortStates, locale }) => {
  if (sortDirection === sortStates.DESC) {
    return compare(cellB, cellA, locale);
  }

  return compare(cellA, cellB, locale);
};
```

### Expansion

`DataTable` introduces the following components to help out with doing row
expansion:

- `TableExpandHeader`: generic component that you place in your `TableHead`.
  Acts as a column placeholder
- `TableExpandRow`: generic component used for a row that you want to be
  expandable
- `TableExpandedRow`: generic component used for the expanded part of a row.
  Anything you place in this component will appear when the row is expanded

In practice, the combination of these components looks like the following:

```jsx
<DataTable
  rows={initialRows}
  headers={headers}
  render={({ rows, headers, getHeaderProps, getRowProps, getTableProps }) => (
    <TableContainer title="DataTable with expansion">
      <Table {...getTableProps()}>
        <TableHead>
          <TableRow>
            {/* add the expand header before all other headers */}
            <TableExpandHeader />
            {headers.map(header => (
              <TableHeader {...getHeaderProps({ header })}>
                {header.header}
              </TableHeader>
            ))}
          </TableRow>
        </TableHead>
        <TableBody>
          {rows.map(row => (
            {/* here we use a React fragment so that both rows are returned in the body */}
            <React.Fragment key={row.id}>
              <TableExpandRow {...getRowProps({ row })}>
                {row.cells.map(cell => (
                  <TableCell key={cell.id}>{cell.value}</TableCell>
                ))}
              </TableExpandRow>
              {/* toggle based off of if the row is expanded. If it is, render TableExpandedRow */}
              {row.isExpanded && (
                <TableExpandedRow colSpan={headers.length + 1}>
                  <h1>Expandable row content</h1>
                  <p>Description here</p>
                </TableExpandedRow>
              )}
            </React.Fragment>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  )}
/>
```

Some things to note:

- `TableExpandHeader` is placed before all other headers as a placeholder/blank
  column
- `TableExpandRow` is what you use instead of `TableRow` for the content of your
  row. We make sure to add `getRowProps` so that it has the right props
- `row.isExpanded` is the field available on `row` to know if the `row` is
  expanded or not
- `TableExpandedRow` is used as a wrapper for any content you want to appear in
  the expanded row
  - Tip: the `colSpan` attribute on the `TableExpandedRow` should be
    `headers.length + 1` in order to span the whole table
  - `TableExpandedRow` should not have a `TableCell` child

#### Programmatic expansion

You can use the `expandRow` action made available through your `render` prop
function to toggle the expansion state of a given row. This method takes in the
row id as a single argument.

### Selection

Selection in a `DataTable` has two parts:

- `TableSelectAll`: component used in the header of the table to select all rows
- `TableSelectRow`: component used to render the selection checkbox in a
  `TableRow`

In practice, it looks like the following in a `DataTable`:

```jsx
<DataTable
  rows={initialRows}
  headers={headers}
  render={({ rows, headers, getHeaderProps, getSelectionProps }) => (
    <TableContainer title="DataTable">
      <Table>
        <TableHead>
          <TableRow>
            <TableSelectAll {...getSelectionProps()} />
            {headers.map(header => (
              <TableHeader {...getHeaderProps({ header })}>
                {header.header}
              </TableHeader>
            ))}
          </TableRow>
        </TableHead>
        <TableBody>
          {rows.map(row => (
            <TableRow key={row.id}>
              <TableSelectRow {...getSelectionProps({ row })} />
              {row.cells.map(cell => (
                <TableCell key={cell.id}>{cell.value}</TableCell>
              ))}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
```

Some items to note:

- `TableSelectAll` is placed before all other headers. It also uses
  `getSelectionProps` to wire up all the necessary actions
- `TableSelectRow` is placed before all the cells in a row. It also uses
  `getSelectionProps`, but it also passes in the specific `row` in order to get
  selection information about the given row.

You can access all the selected rows through the `selectedRows` property passed
into your `render` prop function.

#### Programmatic selection

You can use either of the following actions from your `render` prop function to
update the selection status of a row:

- `selectAll`: invoking this will toggle the selection of all rows, either by
  making all selected or de-selecting all rows
- `selectRow`: invoking this will toggle the selection of a specific row. Takes
  in a valid row id as an argument

### Filtering

Filtering in a `DataTable` is provided through usage of the `TableToolbar` and
the `TableToolbarSearch` component. Any input entered through
`TableToolbarSearch` will be used when the `filterRows` prop is applied. By
default `filterRows` is provided through our default implementation. However,
you can provide your own method if needed.

In practice, this looks like the following:

```jsx
<DataTable
  rows={initialRows}
  headers={headers}
  render={({ rows, headers, getHeaderProps, onInputChange }) => (
    <TableContainer title="DataTable with toolbar">
      <TableToolbar>
        {/* pass in `onInputChange` change here to make filtering work */}
        <TableToolbarSearch onChange={onInputChange} />
        <TableToolbarContent>
          <TableToolbarMenu>
            <TableToolbarAction
              icon={iconDownload}
              iconDescription="Download"
              onClick={action("TableToolbarAction - Download")}
            />
            <TableToolbarAction
              icon={iconEdit}
              iconDescription="Edit"
              onClick={action("TableToolbarAction - Edit")}
            />
            <TableToolbarAction
              icon={iconSettings}
              iconDescription="Settings"
              onClick={action("TableToolbarAction - Settings")}
            />
          </TableToolbarMenu>
          <Button onClick={action("Add new row")} small kind="primary">
            Add new
          </Button>
        </TableToolbarContent>
      </TableToolbar>
      <Table>
        <TableHead>
          <TableRow>
            {headers.map((header) => (
              <TableHeader {...getHeaderProps({ header })}>
                {header.header}
              </TableHeader>
            ))}
          </TableRow>
        </TableHead>
        <TableBody>
          {rows.map((row) => (
            <TableRow key={row.id}>
              {row.cells.map((cell) => (
                <TableCell key={cell.id}>{cell.value}</TableCell>
              ))}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  )}
/>
```

All you need to do to make sure filtering is hooked up is provide the
`onInputChange` handler as the `onChange` prop to `TableToolbarSearch` in your
`TableToolbar` component.

### Batch Actions

Batch actions are typically used when you want to the user to select multiple
rows in your table and then allow them to perform a single action on the
selected rows. To orchestrate this behavior, you'll need to include both the
Table components for selection and for batch actions, which include:

- `TableToolbar`
- `TableToolbarAction`
- `TableBatchActions`
- `TableBatchAction`
- `TableSelectAll`
- `TableSelectRow`

In practice, this looks like the following:

```jsx
<DataTable
  rows={initialRows}
  headers={headers}
  render={({
    rows,
    headers,
    getHeaderProps,
    getSelectionProps,
    getBatchActionProps,
    onInputChange,
    {/* the selected rows are provided as a render prop */
    selectedRows,
  }) => (
    <TableContainer title="DataTable with batch actions">
      <TableToolbar>
        {/* make sure to apply getBatchActionProps so that the bar renders */}
        <TableBatchActions {...getBatchActionProps()}>
          {/* inside of you batch actinos, you can include selectedRows */}
          <TableBatchAction primaryFocus onClick={batchActionClick(selectedRows)}>
            Ghost
          </TableBatchAction>
          <TableBatchAction onClick={batchActionClick(selectedRows)}>
            Ghost
          </TableBatchAction>
          <TableBatchAction onClick={batchActionClick(selectedRows)}>
            Ghost
          </TableBatchAction>
        </TableBatchActions>
        <TableToolbarSearch onChange={onInputChange} />
        <TableToolbarContent>
          <TableToolbarMenu>
            <TableToolbarAction
              icon={iconDownload}
              iconDescription="Download"
              onClick={action('TableToolbarAction - Download')}
            />
            <TableToolbarAction
              icon={iconEdit}
              iconDescription="Edit"
              onClick={action('TableToolbarAction - Edit')}
            />
            <TableToolbarAction
              icon={iconSettings}
              iconDescription="Settings"
              onClick={action('TableToolbarAction - Settings')}
            />
          </TableToolbarMenu>
          <Button onClick={action('Add new row')} small kind="primary">
            Add new
          </Button>
        </TableToolbarContent>
      </TableToolbar>
      <Table>
        <TableHead>
          <TableRow>
            <TableSelectAll {...getSelectionProps()} />
            {headers.map(header => (
              <TableHeader {...getHeaderProps({ header })}>
                {header.header}
              </TableHeader>
            ))}
          </TableRow>
        </TableHead>
        <TableBody>
          {rows.map(row => (
            <TableRow key={row.id}>
              <TableSelectRow {...getSelectionProps({ row })} />
              {row.cells.map(cell => (
                <TableCell key={cell.id}>{cell.value}</TableCell>
              ))}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  )}
/>
```

The import aspects of this example are:

- That we are including the relevant markup for the Table Toolbar
- We are wiring up the Batch Actions component with `getBatchActionProps`. This
  handles toggling the batch action menu for you
- We are reading the `selectedItems` from the `render` prop function in our
  Batch Action click handlers

## Component API

### DataTable props

| Prop                  | Type                                                                                    | Required |
| --------------------- | --------------------------------------------------------------------------------------- | -------- |
| `rows`                | `Array<{ id: string, disabled?: boolean, isSelected?: boolean, isExpanded?: boolean }>` | `true`   |
| `headers`             | `Array<{ key: string, header: ReactNode }>`                                             | `true`   |
| `sortRow`             | `func`                                                                                  | `false`  |
| `filterRows`          | `func`                                                                                  | `false`  |
| `locale`              | `string`                                                                                | `false`  |
| `translateWithId`     | `func`                                                                                  | `false`  |
| `size`                | `'compact'` &#124; `'short'` &#124; `'normal'` &#124; `'tall'`                          | `false`  |
| `radio`               | `boolean`                                                                               | `false`  |
| `stickyHeader`        | `boolean`                                                                               | `false`  |
| `isSortable`          | `boolean`                                                                               | `false`  |
| `overflowMenuOnHover` | `boolean`                                                                               | `false`  |

<h4 id="datatable-render">DataTable render</h4>

The `DataTable` component follows the [render prop pattern](https://reactjs.org/docs/render-props.html) and provides you with two ways to render your table and access the relevant prop getters that you need to build your table.

The first approach is the `render` prop, the second is through the `children`
prop. Both approaches are equivalent in terms of what they offer you, but we
would advise you to use the `children` prop for consistency.

What this means is that the following components would be equivalent ways of
using the render prop for `DataTable`:

```jsx
// `render` prop
<DataTable
  rows={rows}
  headers={headers}
  render={({ rows, headers }) => (
    // Render your table
  )}
/>
// `children` prop
<DataTable
  rows={rows}
  headers={headers}>
  {({ rows, headers }) => (
    // Render your table
  )}
</DataTable>
```

The categories of arguments that this function provides are:

- [Prop Getters](#prop-getters)
- [Actions](#actions)
- [State](#state)
- [Props](#props)

<h5 id="prop-getters">Prop getters</h5>

> See
> [the blog post about prop getters](https://blog.kentcdodds.com/how-to-give-rendering-control-to-users-with-prop-getters-549eaef76acf)

These functions are used to apply props to the elements that you render. The
idea behind this is that it can allow you more flexibility when deciding when to
render, and where, while still allowing `DataTable` to help orchestrate state
changes inside of the Table itself.

You are able to call these on specific elements in your `render` prop function
by doing the following:

```jsx
<TableHeader {...getHeaderProps({ header })}>{header.header}</TableHeader>
```

In order to make sure that everything works as intended, it's important that you
pass all of the `props` that you want to place on the component as fields on the
object you give to a prop getter. For example, if you wanted to add an `onClick`
handler to `TableHeader` above, you would do the following:

```js
<TableHeader {...getHeaderProps({ header, onClick: this.handleOnClick })}>
  {header.header}
</TableHeader>
```

| Property            | Type                    | Description                                              |
| ------------------- | ----------------------- | -------------------------------------------------------- |
| `getHeaderProps`    | `({ header }) => props` | returns the props you should apply to a specific header  |
| `getRowProps`       | `({ row }) => props`    | returns the props you should apply to a specific row     |
| `getSelectionProps` | `({ row? }) => props`   | returns the props you should apply to selection elements |

<h5 id="actions">Actions</h5>

These are functions you can call to change the state of the `DataTable`
component.

| Property        | Type                          | Description                                     |
| --------------- | ----------------------------- | ----------------------------------------------- |
| `sortBy`        | `(headerKey: string) => void` | Sort by the given `headerKey` value             |
| `selectAll`     | `() => void`                  | Toggle the selection status of all rows         |
| `selectRow`     | `(rowId: string) => void`     | Select a specific row by the given `rowId`      |
| `expandRow`     | `(rowId: string) => void`     | Expand a specific row by the given `rowId`      |
| `onInputChange` | `(event: Event) => void`      | Handle the input change of a table search field |

<h5 id="state">State</h5>

These are values that represent the current state of the `DataTable` component.

| Property     | Type    | Description                                     |
| ------------ | ------- | ----------------------------------------------- |
| rows         | `Array` | The array of rows to render for the given table |
| selectedRows | `Array` | the array of currently selected rows            |

<h5 id="props">Props</h5>

As a convenience, `headers` is passed through to make it easier to render the
headers in your table.

<h4 id="datatable-rows">DataTable rows</h4>

The `rows` prop is where you provide us with a list of all the rows that you
want to render in the table. Each item in this list must be an object that has a unique `id` field available on it. For
example:

```js
const rows = [
  {
    id: "a",
    field1: "Field 1a",
  },
  {
    id: "b",
    field1: "Field 1b",
  },
  {
    id: "c",
    field1: "Field 1c",
  },
];
```

You may also pass optional options with each row object to specify a default
state for the row.

| Property     | Type      | Description              |
| ------------ | --------- | ------------------------ |
| `disabled`   | `boolean` | will render row disabled |
| `isSelected` | `boolean` | will render row selected |
| `isExpanded` | `boolean` | will render row expanded |

```js
const rows = [
  {
    id: "a",
    field1: "Field 1a",
    disabled: true,
    isExpanded: true,
  },
  {
    id: "b",
    field1: "Field 1b",
    isSelected: true,
  },
];
```

<h4 id="datatable-headers">DataTable headers</h4>

The `headers` prop represents the order in which the headers should appear in
the table. We expect an array of objects to be passed in, where `key` is the
name of the key in a row object, and `header` is the name of the header. For
example:

```js
// Given that we have the following rows with the fields `foo`, `bar`, and `baz`
const rows = [
  {
    id: "a",
    foo: "Foo a",
    bar: "Bar a",
    baz: "Baz a",
  },
  {
    id: "b",
    foo: "Foo b",
    bar: "Bar b",
    baz: "Baz b",
  },
  {
    id: "c",
    foo: "Foo c",
    bar: "Bar c",
    baz: "Baz c",
  },
];

// We would have a headers array like the following
const headers = [
  {
    // `key` is the name of the field on the row object itself for the header
    key: "foo",
    // `header` will be the name you want rendered in the Table Header
    header: "Foo",
  },
  {
    key: "bar",
    header: "Bar",
  },
  {
    key: "baz",
    header: "Baz",
  },
];
```

<h4 id="datatable-render">DataTable render</h4>

The `render` prop is a function that you give to the `DataTable` component that
takes in a variety of arguments and should ultimately return a valid React
element, or component. This could be as simple or complex as the following
example:

```jsx
// Not very useful, but returns a valid React element
const renderProp = () => <div />;
// Useful and returns a valid React Component
const renderProp = ({ rows, headers, getHeaderProps }) => (
  <TableContainer title="DataTable">
    <Table>
      <TableHead>
        <TableRow>
          {headers.map((header) => (
            <TableHeader {...getHeaderProps({ header })}>
              {header.header}
            </TableHeader>
          ))}
        </TableRow>
      </TableHead>
      <TableBody>
        {rows.map((row) => (
          <TableRow key={row.id}>
            {row.cells.map((cell) => (
              <TableCell key={cell.id}>{cell.value}</TableCell>
            ))}
          </TableRow>
        ))}
      </TableBody>
    </Table>
  </TableContainer>
);
```

The types of arguments that this function has are as follows:

- [Prop Getters](#prop-getters)
- [Actions](#actions)
- [State](#state)
- [Props](#props)

### Prop Getters

> See
> [the blog post about prop getters](https://blog.kentcdodds.com/how-to-give-rendering-control-to-users-with-prop-getters-549eaef76acf)

These functions are used to apply props to the elements that you render. The
idea behind this is that it can allow you more flexibility when deciding when to
render, and where, while still allowing `DataTable` to help orchestrate state
changes inside of the Table itself.

You are able to call these on specific elements in your `render` prop function
by doing the following:

```jsx
<TableHeader {...getHeaderProps({ header })}>{header.header}</TableHeader>
```

In order to make sure that everything works as intended, it's important that you
pass all of the `props` that you want to place on the component as fields on the
object you give to a prop getter. For example, if you wanted to add an `onClick`
handler to `TableHeader` above, you would do the following:

```js
<TableHeader {...getHeaderProps({ header, onClick: this.handleOnClick })}>
  {header.header}
</TableHeader>
```

| property            | type                    | description                                              |
| ------------------- | ----------------------- | -------------------------------------------------------- |
| `getHeaderProps`    | `({ header }) => props` | returns the props you should apply to a specific header  |
| `getRowProps`       | `({ row }) => props`    | returns the props you should apply to a specific row     |
| `getSelectionProps` | `({ row? }) => props`   | returns the props you should apply to selection elements |

### Actions

These are functions you can call to change the state of the `DataTable`
component.

| property        | type                          | description                                     |
| --------------- | ----------------------------- | ----------------------------------------------- |
| `sortBy`        | `(headerKey: string) => void` | Sort by the given `headerKey` value             |
| `selectAll`     | `() => void`                  | Toggle the selection status of all rows         |
| `selectRow`     | `(rowId: string) => void`     | Select a specific row by the given `rowId`      |
| `expandRow`     | `(rowId: string) => void`     | Expand a specific row by the given `rowId`      |
| `onInputChange` | `(event: Event) => void`      | Handle the input change of a table search field |

### State

These are values that represent the current state of the `DataTable` component.

| property     | type    | description                                     |
| ------------ | ------- | ----------------------------------------------- |
| rows         | `Array` | The array of rows to render for the given table |
| selectedRows | `Array` | the array of currently selected rows            |

### Props

As a convenience, `headers` is passed through to make it easier to render the
headers in your table.

### DataTable sortRow

Optional hook to manually control sorting of the rows. You can find more
information about this [here](#custom-sorting).

### DataTable filterRows

Optional hook to manually control filtering of the rows from the
`TableToolbarSearch` component. The signature for the default implementation of
this looks like the following:

```js
/**
 * Default implemention of how we filter rows internally. The idea behind this
 * implementation is to use the given list of row ids and headers to get the
 * individual cell values for a row. Then, we go through each cell value and see
 * if any of them includes the given inputValue.
 *
 * @param {Array[string]} rowIds array of all the row ids in the table
 * @param {Array[Object]} headers
 * @param {Object} cellsById object containing a map of cell id to cell
 * @param {string} inputValue the current input value in the Table Search
 * @returns {Array[string]} rowIds
 */
const filterRows = ({ rowIds, headers, cellsById, inputValue }) => {
  // ...
};
```

### DataTable locale

Provide a string for the current locale. Defaults to `en`. This helps our
default comparison methods better sort numeric inputs.

### Table props

| Prop                  | Type                                                           | Required | Default | Description                                                                                    |
| --------------------- | -------------------------------------------------------------- | -------- | ------- | ---------------------------------------------------------------------------------------------- |
| `className`           | `string`                                                       |          |         | Specify a custom class name for the `<table>`                                                  |
| `isSortable`          | `boolean`                                                      |          | `false` | Specify whether the table is sortable by its columns                                           |
| `overflowMenuOnHover` | `boolean`                                                      |          | `true`  | Specify whether the overflow menu should appear on hover, by default it will always be visible |
| `size`                | `'compact'` &#124; `'short'` &#124; `'normal'` &#124; `'tall'` |          |         | Set the row height for the table                                                               |
| `shouldShowBorder`    | `boolean`                                                      |          |         | Specify whether the table border should be visible                                             |
| `stickyHeader`        | `boolean`                                                      |          |         | Specify whether the header for the table should be sticky                                      |
| `useStaticWidth`      | `boolean`                                                      |          |         | Set `width: auto` on the `<table>` instead of the default `width: 100%`                        |
| `useZebraStyles`      | `boolean`                                                      |          |         | Set to `true` to enable zebra striping in the table                                            |

### TableActionList props

| Prop        | Type     |
| ----------- | -------- |
| `className` | `string` |

### TableBatchAction props

| Prop              | Type                       | Default       | Description                                                                                                 |
| ----------------- | -------------------------- | ------------- | ----------------------------------------------------------------------------------------------------------- |
| `hasIconOnly`     | `boolean`                  |               | Specify if the button is an icon-only button                                                                |
| `iconDescription` | `string`                   |               | If specifying the `renderIcon` prop, provide a description for that icon that can be read by screen readers |
| `renderIcon`      | `function` &#124; `object` | `AddFilled16` | Optional function to render your own icon in the underlying button                                          |

### TableBatchActions props

| Prop                     | Type       | Default | Description                                              |
| ------------------------ | ---------- | ------- | -------------------------------------------------------- |
| `children`               | `node`     |         |                                                          |
| `className`              | `string`   |         |                                                          |
| `onCancel`               | `function` |         |                                                          |
| `shouldShowBatchActions` | `boolean`  |         | Specify whether the batch action bar should be displayed |
| `totalSelected`          | `number`   |         | Specify the total number of items selected in the table  |

### TableBody props

### TableCell props

### TableContainer props

### TableExpandHeader props

### TableExpandRow props

### TableExpandedRow props

### TableHead props

### TableRow props

### TableSelectAll props

### TableSelectRow props

### TableToolbar props

### TableToolbarAction props

### TableToolbarContent props

### TableToolbarSearch props

### TableToolbarMenu props

## Reference

## Feedback

Help us improve this component by providing feedback, asking questions, and leaving any other comments on [GitHub](https://github.com/carbon-design-system/carbon-website/issues/new?assignees=&labels=feedback&template=feedback.md).
